# Journey of a C Program from Code to CPU (Linux)

## What is a Process?  
A **process** is a *running instance of a program*. When you execute a compiled program (for example, by typing its name in a shell), the operating system creates a process to manage it. This process has its own *virtual memory space*, its own registers (CPU state), and other resources. In Linux, “a process is defined as a running instance of a program” – the OS keeps track of each process’s code, stack memory, data, and registers ([Processes & Threads: The Essentials to Mastering Linux | HackerNoon](https://hackernoon.com/processes-and-threads-the-essentials-to-mastering-linux#:~:text=What%20are%20Linux%20Processes%3F)). Each process has a unique ID (PID) and an associated Process Control Block where the kernel records its state.

## What is a Thread?  
A **thread** is a single sequence of execution within a process. Think of a process as a container for one or more threads. Threads in the same process share the process’s code and data, but each thread has its own **stack** and **program counter (PC)**. Threads are often called “lightweight processes” because they share much of their context. As one source explains, “each thread is always part of one specific process” and threads “share code, data, and resources” ([Difference between Process and Thread | GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/#:~:text=Threads%20are%20often%20called%20%E2%80%9Clightweight,states%3A%20Running%2C%20Ready%20and%20Blocked)) ([Difference between Process and Thread | GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/#:~:text=A%20process%20has%20its%20own,Stack%20and%20common%20Address%20space)). This means that if one thread in a process modifies a global variable, other threads see the change immediately. In Linux, the kernel schedules threads much like processes – in fact, “Linux does not differentiate between threads and processes; a thread is just a special kind of process” ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)). 

## Memory Layout of a Process  
 ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/))Each process’s virtual memory is divided into segments, each serving a different purpose. In a typical C program’s memory layout, the segments from low addresses to high are:

- **Text (code) segment:** This holds the compiled program instructions (machine code). It is usually **read-only** to protect the code from being modified at runtime ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=The%20text%20segment%20,while%20the%20program%20is%20running)).  
- **Data segment:** This contains global and static variables. It is divided into **initialized data** (globals given explicit values) and **uninitialized data (BSS)** (globals left uninitialized, which the OS zeroes on start) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=The%20data%20segment%20stores%20global,further%20divided%20into%20two%20parts)) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=B)).  
- **Heap:** This is the area for dynamic allocations (e.g. via `malloc`). The heap grows upward (toward higher addresses) at runtime as the program requests more memory ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=Heap%20segment%20is%20where%20dynamic,calls%20to%20adjust%20its%20size)). All dynamic libraries and `malloc`ed memory live here.  
- **Stack:** This holds function call frames: local variables, return addresses, and parameters. The stack starts at a high address and **grows downward** (toward lower addresses) each time a function is called ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=4)). Each thread gets its own stack. When the stack and heap grow into each other, the program has exhausted its memory. 

An educational note summarizes: “the layout consists of... segments including: stack, heap, data, text” ([CS 225 | Stack and Heap Memory](https://courses.engr.illinois.edu/cs225/fa2023/resources/stack-heap/#:~:text=Each%20running%20program%20has%20its,a%20lot%20of%20segments%2C%20including)). The diagram above illustrates this: text is at low addresses, then data/BSS, then heap; at high addresses is the stack. 

## Compiling a C Program (GCC Toolchain)  
Before execution, the C source code is transformed into a binary executable by GCC. This involves four main phases ([Compiling a C Program: Behind the Scenes | GeeksforGeeks](https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/#:~:text=1.%20Pre,Linking)):

1. **Preprocessing:** Handles directives like `#include` and `#define`. This step expands header files, replaces macros, and removes comments, producing a pure C source file (with extension `.i`).  
2. **Compilation:** Converts the preprocessed C code into assembly language (e.g. an `.s` file). The compiler checks syntax and semantics.  
3. **Assembly:** Translates the assembly code into machine code object files (e.g. `.o` files). Each object file contains binary code and references to external symbols.  
4. **Linking:** Combines object files and libraries into a single executable. The linker resolves symbol references (like library functions) and produces a final binary.  

These phases happen automatically when you run a command like `gcc main.c -o main`. If there are no errors, the output is an executable file (often ELF format on Linux). For example, running `gcc hello.c -o hello` takes the source and ultimately produces an executable named `hello` ([Compiling a C Program: Behind the Scenes | GeeksforGeeks](https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/#:~:text=1.%20Pre,Linking)).

## Launching a Program: `fork()` and `exec()`
When you run an executable, the OS must create a process for it. Typically a shell uses `fork()` and `exec()` system calls to do this. The `fork()` call creates a new process by duplicating the current one: the **child** becomes a copy of the parent (with its own PID and copy of memory) ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=fork,except%20for%20the%20following)). Immediately after `fork()`, most programs call an `exec()` family function (like `execve`). `exec()` *replaces* the process’s memory with a new program’s code and data. In other words, `execve(filename, ...)` loads the executable file into the current process space and starts it at its entry point ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=The%20exec,consists%20of%20following%20functions%2C%20I)) ([Program Loading and Memory Mapping in Linux](https://www.bodunhu.com/blog/posts/program-loading-and-memory-mapping-in-linux/#:~:text=execve%20Syscall)). The child process from `fork()` thus transforms into the new program. In Linux:  
- **`fork()`** duplicates a process (child is copy of parent) ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=fork,except%20for%20the%20following)).  
- **`exec()`** then loads the executable file into that process’s memory space, so it begins executing the new program ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=The%20exec,consists%20of%20following%20functions%2C%20I)) ([Prhile%20the%20program%20is%20running)) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=4)). The OS loads the code, allocates memory pages, and schedules the resulting threads on the CPU cores ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)) ([CPU Scheduling in Operating Systems | GeeksforGeeks](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/#:~:text=CPU%20scheduling%20is%20a%20process,are%20usually%20many%20tasks%20that)). By understanding processes, threads, memory layout, compilation, and scheduling, we see how a simple `printf("Hello");` in C becomes actual instructions executed step-by-step by the CPU under the control of the Linux kernel. 

**Sources:** Authoritative texts and documentation on Linux processes, threads, and compilation processes ([Processes & Threads: The Essentials to Mastering Linux | HackerNoon](https://hackernoon.com/processes-and-threads-the-essentials-to-mastering-linux#:~:text=What%20are%20Linux%20Processes%3F)) ([Difference between Process and Thread | GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/#:~:text=Process%20and%20threads%20are%20the,a%20file%20while%20you%20browse)) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=The%20text%20segment%20,while%20the%20program%20is%20running)) ([Compiling a C Program: Behind the Scenes | GeeksforGeeks](https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/#:~:text=1.%20Pre,Linking)) ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=fork,except%20for%20the%20following)) ([CPU Scheduling in Operating Systems | GeeksforGeeks](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/#:~:text=CPU%20scheduling%20is%20a%20process,are%20usually%20many%20tasks%20that)) ([Virtual Address Space in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-address-space-in-operating-system/#:~:text=Virtual%20address%20space%20refers%20to,a%20result%20of%20this%20characteristic)) ([Virtual Memory in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-memory-in-operating-system/#:~:text=Virtual%20memory%20is%20a%20memory,on%20systems%20with%20less%20RAM)) ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)).ogram Loading and Memory Mapping in Linux](https://www.bodunhu.com/blog/posts/program-loading-and-memory-mapping-in-linux/#:~:text=execve%20Syscall)).  

For example, a shell running `fork()` will have the child process call `execve("/bin/ls", ...)`; after that call, the child’s memory contains the `ls` program, not the shell code.

## CPU Scheduling (Processes and Threads)
 ([CPU Scheduling in Operating Systems | GeeksforGeeks](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/))Once processes and threads exist, the CPU must execute them. The OS *scheduler* decides which thread runs on each CPU core at any time. Because a single CPU core can execute only one thread at a time, the scheduler rapidly switches between ready threads (giving each a small time slice). Scheduling algorithms are often classified as *preemptive* (the OS can interrupt a running task, e.g. Round-Robin) or *non-preemptive* (a task runs to completion, e.g. First-Come-First-Serve). The diagram above shows common types of each. In Linux, the default scheduler (CFS – Completely Fair Scheduler) uses preemptive time-slicing to share CPU fairly. In general, “CPU scheduling is a process used by the OS to decide which task or process gets to use the CPU at a particular time” ([CPU Scheduling in Operating Systems | GeeksforGeeks](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/#:~:text=CPU%20scheduling%20is%20a%20process,are%20usually%20many%20tasks%20that)). 

Key points about scheduling:
- **Time-slicing:** Each runnable thread gets CPU time in turn. When its slice expires, or a higher-priority task appears, the OS context-switches to another thread.  
- **Multiprocessing:** On a multi-core machine, different threads can run in parallel on different cores. The scheduler treats threads from all processes the same way (Linux views threads as schedulable tasks ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section))).  
- **States and Context:** When a switch happens, the kernel saves the thread’s registers and stack pointer and loads another’s. This lets hundreds of processes share few CPUs.  

## Process Memory Allocation (RAM)
When a process starts, the OS allocates memory for it using **virtual memory**. Each process has its own address space (e.g. 0x00000000 up to a high value) that *appears* contiguous and private ([Virtual Address Space in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-address-space-in-operating-system/#:~:text=Virtual%20address%20space%20refers%20to,a%20result%20of%20this%20characteristic)). The OS maps parts of this virtual space to physical RAM pages on demand. For example, the code and static data segments come from the executable file; when the program first runs, those pages are loaded from disk. Additional memory (like the heap) is allocated by the program (e.g. `malloc` internally calls the kernel to get pages). Importantly, due to virtual memory, “a running process does not need to be entirely in memory” ([Virtual Memory in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-memory-in-operating-system/#:~:text=Virtual%20memory%20is%20a%20memory,on%20systems%20with%20less%20RAM)). The OS may keep only needed pages in RAM and can swap others to disk if necessary. A page table keeps track of each virtual page’s physical frame. 

In summary: each process has a distinct virtual address space (so processes don’t see each other’s memory) ([Virtual Address Space in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-address-space-in-operating-system/#:~:text=Virtual%20address%20space%20refers%20to,a%20result%20of%20this%20characteristic)). Memory like the heap and stack grow as needed, and the OS grants physical pages lazily (e.g. on a page fault). This lets processes run even on systems with limited RAM ([Virtual Memory in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-memory-in-operating-system/#:~:text=Virtual%20memory%20is%20a%20memory,on%20systems%20with%20less%20RAM)).

## Thread Execution on CPU Cores
In a multithreaded process, all threads share the same address space but execute independently. Each thread has its own **stack and register state** (including a program counter) ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)). When the scheduler picks a thread to run, that thread’s PC points into the shared code segment, and it executes instructions sequentially. On a multicore CPU, multiple threads from the same process can run truly in parallel on different cores. Because threads share memory, they can communicate through shared variables in the data/heap segment without expensive IPC. 

For example, one source notes that “every process runs in its own memory. Threads share memory” ([Difference between Process and Thread | GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/#:~:text=A%20process%20has%20its%20own,Stack%20and%20common%20Address%20space)). In Linux, threads are scheduled just like processes: each thread is an independent schedulable entity ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)). If there are more ready threads than CPU cores, the OS will quickly context-switch between them (saving and restoring each thread’s state) to give the appearance of simultaneous execution. 

## Summary: From Code to Execution
Putting it all together, here’s the end-to-end flow of a simple C program:  

- **Write and compile the code:** You write C source (e.g. `main.c`) and run `gcc main.c`. GCC preprocesses, compiles, assembles, and links the code into an executable file (phases: preprocessor, compiler, assembler, linker) ([Compiling a C Program: Behind the Scenes | GeeksforGeeks](https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/#:~:text=1.%20Pre,Linking)).  
- **Run the executable:** When you execute the program, the OS creates a process. For example, a shell does `fork()`, then the child does `execve("main", ...)`, loading the program into memory ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=fork,except%20for%20the%20following)) ([Difference between fork() and exec() | GeeksforGeeks](https://www.geeksforgeeks.org/difference-fork-exec/#:~:text=The%20exec,consists%20of%20following%20functions%2C%20I)). The process now has the program’s text, data, heap, and a fresh stack set up in its virtual address space ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=The%20text%20segment%20,while%20the%20program%20is%20running)) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=4)).  
- **Process begins execution:** The program’s initial thread (the “main” thread) starts running at the first instruction. Local variables go on its stack; any `malloc` calls carve out space on the heap ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=Heap%20segment%20is%20where%20dynamic,calls%20to%20adjust%20its%20size)) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:~:text=4)).  
- **Threads run on CPU:** If the program creates additional threads, each thread gets its own stack and can run on any CPU core. The OS scheduler treats these threads as tasks: it picks which thread runs on which core, preempting them in turn ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)) ([CPU Scheduling in Operating Systems | GeeksforGeeks](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/#:~:text=CPU%20scheduling%20is%20a%20process,are%20usually%20many%20tasks%20that)). All threads execute instructions from the shared code in the text segment, accessing shared data or heap as needed ([Difference between Process and Thread | GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/#:~:text=A%20process%20has%20its%20own,Stack%20and%20common%20Address%20space)) ([Life-long-Learner/linux-kernel-development/chapter-3.md at master · firmianay/Life-long-Learner · GitHub](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-3.md#:~:text=section)).  
- **Memory management:** As the program executes, the OS handles memory. Virtual pages for code/data are loaded from disk as needed, and new pages for heap and stack are allocated by the kernel on demand. The process runs under the illusion of having its own contiguous memory space ([Virtual Address Space in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-address-space-in-operating-system/#:~:text=Virtual%20address%20space%20refers%20to,a%20result%20of%20this%20characteristic)) ([Virtual Memory in Operating System | GeeksforGeeks](https://www.geeksforgeeks.org/virtual-memory-in-operating-system/#:~:text=Virtual%20memory%20is%20a%20memory,on%20systems%20with%20less%20RAM)).  
- **Termination:** When the program finishes (e.g. `main` returns), the process calls `exit()` and the OS reclaims all its resources (memory, file handles, etc.). The kernel updates the scheduler so this process no longer receives CPU time.

In summary, a C program’s journey involves writing source code, compiling it into a binary, and then the OS creating a process to run that binary. The process’s memory is neatly laid out in segments (text, data, heap, stack) ([Memory Layout of C Programs | GeeksforGeeks](https://www.geeksforgeeks.org/memory-layout-of-c-program/#:
