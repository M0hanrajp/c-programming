#include "daemon.h"
#include <stdio.h>
#include "glib.h"
#include "xml_to_string.h"
#include "mpunix-daemon-Sub.h"

#define OBJECT_PATH "/com/mpunixDaemon"
#define INTERFACE_ADD   "com.mpunixDaemon.Add"
#define INTERFACE_SUB   "com.mpunixDaemon.Sub"

const gchar *defineIntrospectXML(const char *fileName) {
    // parse the XML
    xmlDocPtr file = openFile(fileName);

    const gchar *xmlString= NULL;
    if(file != NULL)
        xmlString = xmlToString(file);

    // Free allocated memory
    xmlFreeDoc(file);
    xmlCleanupParser();
    return xmlString;
}

GDBusInterfaceInfo *createInterfaceInfo(const gchar *fileName) {
    const gchar *xmlData = defineIntrospectXML(fileName);

    printf("[INFO]: XML data parse complete @ %s\n", __func__);

    // https://docs.gtk.org/gio/struct.DBusNodeInfo.html
    GDBusNodeInfo *nodeInfo =

        // https://docs.gtk.org/gio/ctor.DBusNodeInfo.new_for_xml.html
        g_dbus_node_info_new_for_xml(xmlData, /* const gchar *xml_data */
                                     NULL /* GError **error */);

    // https://docs.gtk.org/gio/struct.DBusInterfaceInfo.html
    GDBusInterfaceInfo *interfaceInfo =

        // https://docs.gtk.org/gio/method.DBusNodeInfo.lookup_interface.html
        g_dbus_node_info_lookup_interface(nodeInfo, /* GDBusNodeInfo *info */
                                          INTERFACE_ADD /* const gchar *name */);

    /* g_object_unref(nodeInfo);
     * adding this was giving SIGSEV error,
     * need to understand unref and ref */
    return interfaceInfo;
}

void onAddMethodCall(GDBusConnection *connection,
                        const gchar *sender,
                        const gchar *object_path,
                        const gchar *interface_name,
                        const gchar *method_name,
                        GVariant *parameters,
                        GDBusMethodInvocation *invocation,
                        gpointer user_data) {

    gint32 a = 0, b = 0;
    // https://docs.gtk.org/glib/method.Variant.get.html
    g_variant_get(parameters, "(ii)", &a, &b);
    gint32 sum = a + b;

    // https://docs.gtk.org/glib/ctor.Variant.new.html
    // https://docs.gtk.org/glib/gvariant-format-strings.html
    GVariant *reply = g_variant_new("(i)", sum);

    // https://docs.gtk.org/gio/method.DBusMethodInvocation.return_value.html
    // TODO: handle error scenario for invalid user input 
    // using g_dbus_method_invocation_return_error()
    g_dbus_method_invocation_return_value(invocation, reply);
}

/* Please note that for this daemon we are not using gdbus-codgen autogenerated 
 * code for creating a skeletion object and exporting it to interface instead we 
 * are using GDBusInterfaceVTable to specify our methods
 */
// https://docs.gtk.org/gio/struct.DBusInterfaceVTable.html
static const GDBusInterfaceVTable mpunixDaemonVTable = {
    .method_call = onAddMethodCall,
    // since values are provided by gdbus call, no get/set properties are used.
    .get_property = NULL,
    .set_property = NULL
};

/* the following sub handler subtracts two numbers
 * it's done using gdbus-codegen autogenerated code
 * for gdbus-codegen related
 * https://docs.gtk.org/gio/class.DBusInterfaceSkeleton.html*
 */
void onSubMethodCall(ComMpunixDaemonSub      *object,
                                GDBusMethodInvocation *invocation,
                                gint                   arg_c,
                                gint                   arg_d,
                                gpointer               user_data) {
    // operation
    gint result = arg_c - arg_d;
    // send invocation "response" back to caller
    com_mpunix_daemon_sub_complete_sub(object, invocation, result);
}

// when bus is acquired
extern void onBusAcquiredHandler(GDBusConnection* connection,
                                    const gchar* name,
                                    gpointer user_data) {

    printf("[INFO]: Bus acquired successfully\n");

    GDBusInterfaceInfo *interfaceInfo = createInterfaceInfo("introspect_add.xml");
    printf("[INFO]: XML parsed, GDBusInterfaceInfo is created\n");

    GError *error = NULL;
    guint registrationID =
        // https://docs.gtk.org/gio/method.DBusConnection.register_object.html
        g_dbus_connection_register_object(connection, /* GDBusConnection *connection */
                                          OBJECT_PATH, /* const gchar *object_path */
                                          interfaceInfo, /* GDBusInterfaceInfo *interface_info */
                                          &mpunixDaemonVTable, /* const GDBusInterfaceVTable *vtable */
                                          NULL, /* gpointer user_data */
                                          NULL, /* GDestroyNotify user_data_free_func */
                                          &error /* GError **error */);

    if(registrationID == 0)
        printf("[ERROR]: Add method registration failed %s\n", error->message);
    else
        printf("[INFO]: (VTable) - Add method registration complete\n");

    // gdbus codegen on registering a method
    // 1. cerate the object
    ComMpunixDaemonSub *skeleton = com_mpunix_daemon_sub_skeleton_new();
    // 3. Hook our handler into the “handle-sub” signal
    g_signal_connect(skeleton, "handle-sub", G_CALLBACK(onSubMethodCall), NULL);
    // 2. export the object at desired path
    // https://docs.gtk.org/gio/method.DBusInterfaceSkeleton.export.html
    GError *err = NULL;
    if(!g_dbus_interface_skeleton_export(G_DBUS_INTERFACE_SKELETON(skeleton),
                                         connection,
                                         OBJECT_PATH,
                                         &err)) {
        printf("[INFO]: Failed to create dbus interface %s\n", err->message);
        exit(-1);
    }
    printf("[INFO]: (gdbus-codegen) - Sub method registration complete\n");
}

// When bus name is acquired
extern void onNameAcquiredHandler(GDBusConnection* connection,
                                    const gchar* name,
                                    gpointer user_data) {

    printf("[INFO]: Bus name acquired, daemon active..\n");
}

// when bus name is lost
extern void onNameLostHandler(GDBusConnection* connection,
                                const gchar* name,
                                gpointer user_data) {

        printf("[INFO]: Bus name Lost!\n");
        //TODO: using registrationID & InterfaceInfo gracefully close
}
